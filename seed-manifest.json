{
  "version": "2.3",
  "description": "Cortex seed manifest. The agent creates each file at the specified path under cortex/data/.",
  "files": [
    {
      "path": "cortex/data/system/rules.md",
      "content": "# Cortex Operating Rules\n\nThese rules govern agent behavior in every Cortex session. They are system-level\ninstructions, not user preferences. Do not modify — updates arrive via version bumps.\n\nVersion: 2.2\n\n1. Principles are append-only. Never rewrite without user approval.\n2. Diary entries are written during sessions, not reconstructed after.\n3. Active memory is updated each session. Lessons are append-only.\n4. Trigger responses are concise. Action, not explanation.\n5. Internal triggers run silently unless the user asks.\n6. Monitoring is the boot state. After boot, all conversation is a knowledge\n   source. When a principle, pattern, lesson, constraint, or vocabulary term\n   emerges, capture it to the appropriate file and briefly note what was captured.\n7. Synthesis refines conclusions, not raw material. Turn observations into proper\n   terminology and actionable protocols. But preserve raw artifacts in their\n   natural form.\n8. Preserve any Cortex bootstrap sections when rewriting agent context files\n   (replit.md, CLAUDE.md, etc.).\n"
    },
    {
      "path": "cortex/data/system/architecture.md",
      "content": "# Memory Architecture\n\nCortex organizes knowledge into tiers. Each tier has a storage location, a\nlifecycle, and rules for when it loads into agent context.\n\nVersion: 2.2\n\n## Always Loaded at Boot (RAM)\n\n- **Goals** (`principles/goals.md`) — Permanent. Why we're building. Append-only.\n- **Rules** (`principles/rules.md`) — Permanent. How to operate. Merged constraints\n  (\"never do X\") and best practices (\"always do Y\"). User-captured operational\n  rules, conventions, and boundaries. Append-only. Distinct from system/rules.md\n  which governs agent behavior.\n- **Active Memory** (`memory/active.md`) — Working set. Where we left off, open\n  issues, next steps. Updated each session.\n- **Lessons** (`memory/lessons.md`) — Permanent. What went wrong. Failure patterns,\n  prevention strategies. Append-only. A lesson that matures into an operating\n  constraint can be promoted to Rules.\n- **Vocabulary** (`vocabulary.md`) — Contextual. Shorthand, synonyms,\n  project-specific terms. Ages over time (hot > warm > cold > archived).\n- **Profile** (`memory/profile.md`) — Who we're working with. Self-disclosed facts\n  only, never inferred. Living data that updates as the user changes. Calibrates\n  communication; does not constrain capability.\n\n## Loaded on Demand (Disk)\n\n- **Diary** (`diary/YYYY/MM/DD.md`) — Permanent. One file per day. Only the most\n  recent entry is read at session start for continuity. Older entries searched\n  on demand.\n- **Projects** (`projects/[slug].md`) — Multi-session missions with tasks,\n  session logs, and notes. Active projects scanned at boot; completed/paused\n  projects loaded on demand.\n- **Considerations** (`memory/considerations.md`) — Things connected to our work\n  that might matter later. Stored, not loaded at boot. Searched on demand when\n  relevant context arises.\n\n## Archive\n\n- **Archive** (`archive/`) — Aged-out memories. Moved here when no longer\n  relevant to active work. Searchable but never auto-loaded.\n"
    },
    {
      "path": "cortex/data/system/genesis.md",
      "content": "# Genesis Protocol\n\nThis file documents the full Cortex genesis sequence. It is created during the\nfirst install and kept as a reference for re-runs or recovery.\n\nVersion: 2.3\n\n## When Genesis Runs\n\nGenesis runs when the slim file (`cortex.md`) detects that `cortex/data/` does\nnot exist. This happens on first install or after a clean reinstall.\n\n## Prerequisites\n\n- `cortex.md` (the slim file) must exist somewhere in the project.\n- The agent must have already read `cortex.md` in the current session. If the\n  agent doesn't recognize the genesis instructions, the user needs to point\n  the agent to cortex.md first.\n\n## Sequence\n\nGenesis has five phases. Each phase completes before the next begins. Every\nquestion asked must produce something the system uses — no conversation for\nconversation's sake.\n\n### Phase 1: Confirm & Create\n\n1. Verify this is intentional. Respond: \"Birth Cortex here? This creates the\n   data layer and configures the system. Type 'yes' to confirm.\"\n2. **Resolve CORTEX_ROOT** — the directory containing `cortex.md`. All paths\n   below are relative to CORTEX_ROOT. Report: \"CORTEX_ROOT: [resolved path]\"\n3. Detect platform automatically (check for replit.md, CLAUDE.md, .cursorrules,\n   .windsurfrules). Report which platform was detected. If the platform has a\n   restricted file system, relocate the DNA: copy cortex.md into the allowed\n   directory, update CORTEX_ROOT to that path, and report the relocation.\n4. Create directories under `cortex/data/`:\n   - `system/`\n   - `diary/`\n   - `principles/`\n   - `memory/`\n   - `projects/`\n   - `triggers/`\n   - `templates/`\n   - `releases/`\n   - `archive/`\n5. Create system files with their full content from the seed manifest:\n   - `system/rules.md` — 8 behavioral rules\n   - `system/architecture.md` — memory tier descriptions\n   - `system/genesis.md` — this file (genesis protocol reference)\n   - `triggers/standard.md` — 19 standard trigger entries\n   - `triggers/custom.md` — `# Custom Triggers`\n6. Create user data stubs (empty seed files):\n   - `principles/goals.md` — `# Goals`\n   - `principles/rules.md` — `# Rules`\n   - `memory/active.md` — `# Active Memory`\n   - `memory/lessons.md` — `# Lessons`\n   - `memory/profile.md` — `# Profile`\n   - `memory/considerations.md` — `# Considerations`\n   - `vocabulary.md` — `# Vocabulary`\n7. Create `data/what-is-cortex.md` from the What-Is-Cortex Template (below).\n8. Add Cortex bootstrap to the detected platform's agent context file. Use\n   the exact template from the Bootstrap Restoration section below. The path\n   in the bootstrap must point to CORTEX_ROOT/cortex.md:\n\n   ```\n   ## Cortex — ACTIVE INSTRUCTION\n   <!-- DO NOT REMOVE OR ALTER THIS SECTION. It is the bootstrap for the Cortex memory system. If this section is missing, tell the agent: \"Read and act on [CORTEX_ROOT/cortex.md]\" to restore it. -->\n\n   **EXECUTE NOW:** Read `[CORTEX_ROOT/cortex.md]` and act on its instructions.\n   ```\n\n9. Do NOT modify cortex.md — it is the slim file, already present.\n\n### Phase 2: Interview (2 questions)\n\nAsk these two questions. Each one writes directly to the data layer.\n\n1. **\"What's this project about, in a sentence?\"**\n   → Seeds `principles/goals.md` with the project's purpose.\n   → Generates `data/vision.md` — a full elevator-pitch document synthesized\n   from the answer, explaining what the project is, the problem it solves,\n   and why it matters. Use the Vision Template below.\n\n2. **\"How do you prefer to work with me — as an architect (I help you think\n   and design before building), a builder (I focus on shipping — less talk,\n   more code), or a guide (I explain my reasoning and teach as we go)?\"**\n   → Seeds `memory/profile.md` with the working style preference.\n   → Calibrates communication style: architect gets deliberate design\n   discussion, builder gets concise action-oriented responses, guide gets\n   detailed explanations with reasoning.\n\nMonitoring is always active — there is no opt-out question. The agent\ncaptures principles and patterns as they emerge in every session.\n\n### Phase 3: Consent-to-Scan\n\nAsk: **\"I'd like to look around the project now — scan the file structure,\ncheck for documentation, see what frameworks you're using, look at git\nhistory. OK to proceed?\"**\n\nIf yes, perform the scan and report results conversationally as they're found:\n\n1. **File structure** — language, framework, key directories.\n   Report: \"Found a [language]/[framework] project...\"\n2. **Documentation** — scan for docs/, PRDs, READMEs, design files, ADRs.\n   Enumerate each discoverable file by name and location.\n   Report: \"Found [N] documents in [location]: [list]...\"\n3. **Git history** — author count, age, commit frequency.\n   Report: \"Git shows [details]...\"\n4. **Dependencies** — package manager, key libraries.\n   Report: \"Using [key dependencies]...\"\n5. **Existing conventions** — code style, patterns, architecture, error\n   handling, naming conventions, testing patterns.\n   Report: \"Noticed [patterns]...\"\n\nWrite findings to `memory/active.md` under a \"## Project Scan\" section.\nInclude the enumerated list of discovered knowledge sources (documentation\nfiles, READMEs, config files with embedded conventions) — this list informs\nthe Deep Seeding offer in Phase 3b.\n\nAfter the scan, ask **1-2 follow-up questions** that are specific to what\nwas discovered — questions that couldn't have been asked before the scan.\nOnly ask follow-ups if the scan surfaced something genuinely ambiguous. If\neverything is clear, proceed to Phase 3b.\n\n### Phase 3b: Deep Seeding (Optional)\n\nThis phase is entirely optional. It only runs if the Phase 3 scan discovered\nknowledge sources (documentation, PRDs, READMEs, architecture files, code\nconventions) worth reading in depth. If no meaningful sources were found,\nskip to Phase 4.\n\n**Guard:** This phase requires its own explicit permission — the Phase 3\nconsent does not carry over.\n\nAsk: **\"The scan found [N] knowledge sources — [brief list: e.g., '3 PRDs,\n2 READMEs, an architecture doc']. I can read through them and suggest\ninitial principles, vocabulary, and lessons to give Cortex a running start.\nThis is optional — nothing gets written without your approval. Want me to\ntake a look?\"**\n\nIf no, skip to Phase 4. If yes:\n\n1. **Read discovered sources.** Read each enumerated document and code\n   convention file identified in Phase 3. Focus on extractable knowledge:\n   stated goals, design decisions, rules, naming conventions, architectural\n   patterns, domain vocabulary, past lessons.\n\n2. **Draft suggestions.** Group extracted knowledge by destination:\n   - **Candidate goals** → would go in `principles/goals.md`\n   - **Candidate rules** → would go in `principles/rules.md`\n   - **Candidate vocabulary** → would go in `vocabulary.md`\n   - **Candidate lessons** → would go in `memory/lessons.md`\n\n3. **Present for approval.** Show all suggestions grouped by category:\n\n   ```\n   ## Suggested Seeds ([N] total)\n\n   ### Goals ([N])\n   - [suggestion 1]\n   - [suggestion 2]\n\n   ### Rules ([N])\n   - [suggestion 1]\n\n   ### Vocabulary ([N])\n   - [term] — [definition]\n\n   ### Lessons ([N])\n   - [lesson]\n\n   Approve all, cherry-pick, or skip?\n   ```\n\n4. **Write approved items only.** Append approved items to the appropriate\n   data layer files. Tag each with `[genesis-seeded]` and today's date so\n   they're distinguishable from organically captured knowledge. Example:\n   `- **Error boundaries (2026-02-08) [genesis-seeded]:** All React\n   components must have error boundaries at route level.`\n\n5. **Report.** Respond: \"Seeded [N] items: [N] goals, [N] rules, [N]\n   vocabulary terms, [N] lessons.\" If the user skipped or cherry-picked,\n   note what was excluded: \"Skipped [N] suggestions.\"\n\n**Rules:**\n- **Never auto-write.** Every suggestion must be presented and approved\n  before being written.\n- **No duplicates.** If a suggestion overlaps with something already\n  captured in Phase 2 (e.g., the project purpose in goals.md), skip it.\n- **Synthesis, not copying.** Extracted items should be distilled and\n  actionable — not raw quotes from documents. \"Said better,\" not \"said\n  in academese.\"\n- **Source attribution.** When presenting suggestions, note which source\n  each came from so the user can judge relevance: \"From docs/architecture.md:\n  [suggestion].\"\n\n### Phase 4: Self-Test\n\nRun a verification sequence and report results:\n\n1. **File I/O** — Write a test note to today's diary (`::n Genesis\n   self-test`), read it back, confirm it persists. Report: pass/fail.\n2. **Principle capture** — The project description from Phase 2 should\n   already be in `principles/goals.md`. Read it back and confirm.\n   Report: pass/fail.\n3. **System files** — Confirm `system/rules.md`, `system/architecture.md`,\n   and `system/genesis.md` exist and are readable. Report: pass/fail.\n4. **Triggers** — Confirm `triggers/standard.md` exists and contains 19\n   trigger entries (count `####` headers: 15 user including ::nt? + 4\n   internal). Report: pass/fail.\n5. **Live test** — Run `::lt`. Report: pass/fail (expect \"Monitoring:\n   active — context will survive\").\n6. **Bootstrap check** — Read the platform context file and confirm the\n   Cortex bootstrap section is present and uses the correct directive\n   language. Report: pass/fail.\n\nIf any test fails, fix it immediately and re-test. Report: \"All systems\nverified\" or \"Fixed [issue], all systems verified.\"\n\n### Phase 5: First Diary Entry\n\nWrite the birth diary entry at `diary/YYYY/MM/DD.md` containing:\n- CORTEX_ROOT location\n- What was created (data layer, bootstrap, vision.md)\n- Platform detected\n- Interview answers and how they configured the system\n- Scan findings (if consent was given)\n- Self-test results\n\nRespond with the Quick Start:\n\nGenesis complete. Cortex is installed and monitoring is active.\n\n**Quick Start**\n\n- **Cortex is already watching.** Monitoring is on — it captures principles, vocabulary, and lessons from your conversation automatically. You don't need to do anything.\n- **`::ingest` when something matters.** Monitoring catches a lot, but when you want to deliberately capture a decision, a lesson, or something from a document, say `::ingest`.\n- **`::lt` to check the pulse.** Quick health check. If Cortex is loaded, you'll see \"Monitoring: active — context will survive.\" If something feels off, start here.\n- **`::se` when you're done.** Writes your session diary, updates projects, and sets up your next session. The one habit worth building.\n\nType `::?` anytime to see all available commands.\n\n## What-Is-Cortex Template\n\nUsed by genesis to create `what-is-cortex.md` in new projects:\n\n```\n# What is Cortex?\n\nCortex is a collaborative memory system between a human and an AI agent.\n\nIt solves three problems:\n1. AI agents lose all context between sessions. Cortex gives them persistent memory.\n2. Projects accumulate hard-won knowledge (principles, patterns, lessons) that gets lost. Cortex captures and organizes it.\n3. There's no protocol for when and how an agent should refresh its memory. Cortex defines explicit triggers.\n\n## How It Works\n\nThe system has two layers:\n- **DNA** (cortex.md) — The portable core. Contains trigger index, behavioral\n  rules, and boot instructions. Full trigger definitions and protocols are\n  stored in system files or fetched from the server.\n- **Data layer** (data/) — The memories. Diary entries, principles, active\n  memory, lessons learned. Generated by genesis, unique to each project.\n\n## Triggers\n\nType ::? to see all available triggers.\n\n## Design Philosophy\n\n- Human-readable files, not opaque embeddings\n- Collaborative — both human and agent contribute\n- Explicit protocols over implicit hope\n- Append-only principles, living memory\n```\n\n## Vision Template\n\nUsed by genesis Phase 2 to generate `data/vision.md` from the user's project\ndescription. The agent synthesizes this from the one-sentence project answer,\nexpanding it into a full pitch:\n\n```\n# [Project Name]: Why It Exists\n\n## The Problem\n[What problem does this project solve? Why does the current state of things\nfall short?]\n\n## What [Project Name] Is\n[One-paragraph description of what the project does and how it works at a\nhigh level.]\n\n## What It Provides\n[Key capabilities — 3-5 bullet points describing the core value.]\n\n## Design Principles\n[3-5 principles that guide how the project is built. Inferred from the\ndescription and scan findings.]\n\n## Who It's For\n[One-paragraph description of the target audience.]\n```\n\nThe agent should fill this template thoughtfully, not generically. Use\nspecifics from the user's answer and (if available) the project scan findings\nfrom Phase 3. If the scan hasn't happened yet, write the vision from the\ninterview answer alone — it can be enriched later.\n\n## Bootstrap Restoration\n\nIf the Cortex section in the agent context file is missing or damaged, the\nuser cannot reach any triggers. This section contains the exact content to\nrestore it, plus the recovery protocol.\n\n**Recovery path for the user:** Tell the agent \"Read and act on\n`[path-to]/cortex.md`\" — the agent will find this section and self-heal.\n\n**Restore protocol (for the agent reading this):**\n1. Identify the agent context file for this platform (replit.md, CLAUDE.md,\n   .cursorrules, .windsurfrules)\n2. Resolve the path to cortex.md — this is CORTEX_ROOT/cortex.md\n3. Check the agent context file for a section titled\n   `## Cortex — ACTIVE INSTRUCTION`\n4. If missing or incomplete, insert the following block into that file\n   immediately after the project Overview section (or as early as possible\n   in the file — visibility is critical). Replace `[CORTEX_ROOT/cortex.md]`\n   with the actual resolved path:\n\n   ```\n   ## Cortex — ACTIVE INSTRUCTION\n   <!-- DO NOT REMOVE OR ALTER THIS SECTION. It is the bootstrap for the Cortex memory system. If this section is missing, tell the agent: \"Read and act on [CORTEX_ROOT/cortex.md]\" to restore it. -->\n\n   **EXECUTE NOW:** Read `[CORTEX_ROOT/cortex.md]` and act on its instructions.\n   ```\n\n5. After inserting, respond: \"Bootstrap restored. Cortex will load\n   automatically on next session.\"\n"
    },
    {
      "path": "cortex/data/triggers/standard.md",
      "content": "# Standard Triggers\n\nVersion: 2.3\nDo not edit — updates arrive via version bumps. For custom triggers, use ::nt.\n\n---\n\n## User Triggers\n\n#### ::ss\n**Purpose:** Session start — full briefing, run live test, activate monitoring.\n**Payload:** No\n**Prompt to self:** Execute boot sequence. Read `system/rules.md` and `system/architecture.md`. Read `memory/active.md`, `memory/lessons.md`, `vocabulary.md`. Read `memory/profile.md` if it exists — calibrate communication to match the user's level and working style. Read all files in `principles/` — goals and rules. Read the most recent diary entry for orientation. Scan `projects/` for active projects:\n- **Tracked projects** (Track in sessions: yes): Read the file, report name, type, task progress, and next incomplete tasks. Nudge: \"Hey, we still have [project name] open — [N tasks remaining]. Want to pick that up?\"\n- **Untracked projects** (Track in sessions: no): Quiet one-liner only — \"[project name] — [N/M tasks]\"\n- **Dormant projects** (active but no session log entry in 5+ sessions): Flag with a nudge — \"[project name] hasn't been touched in a while — still relevant?\"\nCheck for updates: read the local version from line 1 of the slim file (`cortex/cortex.md`), extract the version number. Attempt to fetch `https://raw.githubusercontent.com/dvn66/cortex/main/cortex.md` and extract the remote version from line 1. If the fetch fails, skip silently. If local < remote, append to the session start report: \"Update available: v{local} → v{remote} — run ::update\". If local >= remote, no output.\nRun `::lt` (the live test trigger). Report: last diary summary (3-4 lines), active memory items, principle count, project status section, live test card. End with \"Ready.\"\n\n#### ::se\n**Purpose:** Session end — diary, projects, memory sync.\n**Payload:** No\n**Prompt to self:** This trigger has three jobs — write today's permanent record, update project state, and prepare for tomorrow.\n1. **Diary (permanent record):** Review the full conversation. Write/update today's diary narrative (`diary/YYYY/MM/DD.md`) — what happened, what was decided, what was discovered. This is the story. It stays forever.\n2. **Project updates:** For every active project that was worked on during the session: update the session log with what happened, check off completed tasks, update task progress. For tracked projects, include a progress summary in the session-end report.\n3. **Active memory (working set):** Update `memory/active.md` with: where we left off, open issues, next steps. Include current project states. Flag items older than 5 sessions for archiving.\n4. **Principle check:** Monitoring should have captured most principles during the session. Do a final scan — if anything was missed, capture it now.\nReport: summary of diary written, project progress updates (for tracked projects), active memory updates, any new principles captured.\n\n#### ::lt\n**Purpose:** Live test — lightweight keep-alive, verify Cortex is loaded.\n**Payload:** No\n**Prompt to self:** Three checks:\n1. Is the slim file (`cortex/cortex.md`) present and readable?\n2. Does `data/` exist?\n3. Is `memory/active.md` readable?\nIf all three pass, respond exactly: \"Monitoring: active — context will survive\"\nIf any check fails, respond: \"Monitoring: failed — [which check failed]. Re-run ::boot.\"\n\n#### ::?\n**Purpose:** Show trigger help.\n**Payload:** No\n**Prompt to self:** Display the following table exactly. If `triggers/custom.md` contains any custom triggers, append them at the end of the table with a `[custom]` tag in the description.\n\n```\n| Trigger | What it does |\n|---------|-------------|\n| `::?` | Show this help |\n| `::se` | Wrap up your session — writes diary, updates projects, syncs memory for next time |\n| `::lt` | Check if Cortex is loaded — expect \"Monitoring: active — context will survive\" |\n| `::r` | Refresh your working memory — reloads principles, lessons, and active memory |\n| `::ingest [text]` | Capture a specific insight as a principle or lesson. Omit text to extract from recent conversation |\n| `::n [text]` | Jot a quick note — gets appended to today's diary |\n| `::d` | Turn today's notes and conversation into a diary narrative |\n| `::proj` | See all your projects grouped by status |\n| `::proj [description]` | Start a new project — Cortex will break it into tasks and track it |\n| `::verbatim [N]` | Grab the last N exchanges exactly as written — no cleanup, no summary (default: 1) |\n| `::wtf [description]` | Something broke — describe it and Cortex will diagnose |\n| `::nt [code] [purpose]` | Create a new custom trigger |\n| `::update` | Check for a newer version and apply it one step at a time |\n| `::uninstall` | Remove Cortex from this workspace — your data is preserved |\n\nAppend `?` to any trigger for extended help (e.g., `::proj?`, `::ingest?`).\n```\n\n#### ::n payload\n**Purpose:** Capture a note to today's diary.\n**Payload:** Yes — text to capture.\n**Prompt to self:** Append the payload text to today's diary file (`diary/YYYY/MM/DD.md`) under a \"## Notes\" section with timestamp. Create the file and parent directories if they don't exist. Respond: \"Noted.\"\n\n#### ::d\n**Purpose:** Write today's diary narrative.\n**Payload:** No\n**Prompt to self:** Read today's notes from the diary file. Review the conversation for additional context. Write an executive summary narrative at the top of the file under \"## Summary\". Style: release-note tone, include what was accomplished, what went wrong, what was discovered. Keep it under 500 words. Respond: \"Diary written.\" followed by a 2-line preview.\n\n#### ::r\n**Purpose:** Review all principles, lessons, memory, and projects.\n**Payload:** No\n**Prompt to self:** Read all files in `principles/` — goals and rules. Read `memory/lessons.md`. Read `memory/active.md`. Read active project status. Internalize. Respond: \"[count] goals, [count] rules, [count] lessons loaded. Active memory current. [project status if applicable].\"\n\n#### ::ingest [payload]\n**Purpose:** Capture knowledge — with text: file one item; without: extract from context.\n**Payload:** Optional — text to capture.\n**Prompt to self:** Two modes:\n(1) With payload text: Parse the text as a single knowledge item. Determine category (goal, rule, or lesson). Append to the appropriate principles file with today's date. Respond: \"Added to [category]: [one-line summary].\"\n(2) Without payload: Look back at recent conversation for what the user is referring to — this could be a file they uploaded, a document they mentioned, a discussion that just happened, or a decision that was made. Read/review that material. Extract any knowledge that qualifies as a goal, rule, lesson, pattern, or vocabulary term. Append extracted items to the appropriate data layer files (`principles/`, `memory/lessons.md`, `vocabulary.md`). Respond with a synopsis: what was absorbed and where it went. If nothing extractable was found, say so.\nWhen you don't need `::ingest`: Passive monitoring (activated at boot) already captures principles and lessons as they emerge in conversation. Use `::ingest` when you want to deliberately absorb something monitoring might not catch — like an uploaded file, a long design discussion, or external material brought in.\n\n**Alias:** `::p` works identically to `::ingest`.\n\n#### ::proj [payload]\n**Purpose:** Current project — tasks, status, notes.\n**Payload:** Optional — project name, \"done\", \"pause\", or new project description.\n**Prompt to self:** Parse the payload to determine the action:\n- **No payload** (`::proj`): **Project dashboard.** List all projects in `projects/`. Group by status: Active first, then Dormant (active but no session log entry in 5+ sessions), then Completed. Show name, type, size, task progress (e.g., \"3/8 complete\"), and whether session tracking is on. Format:\n  ```\n  ## Active\n  - [Project Name] (type, size) — 3/8 tasks [tracked]\n  ## Dormant\n  - [Project Name] (type, size) — 1/5 tasks [untracked]\n  ## Completed\n  - [Project Name] (type) — done 2026-02-07\n  ```\n- **`done` or `done [project-name]`** (`::proj done`): Mark the current or specified project as `Status: completed` with today's date. The file stays in `projects/` — never deleted.\n- **`pause` or `pause [project-name]`** (`::proj pause`): Mark the current or specified project as `Status: paused`. It will appear under \"Dormant\" in the dashboard. Resume by updating the file manually or working on it again.\n- **Anything else** (`::proj Build a notification system`): This is a new project description. Run the **Project Interview** then create the project file.\n\n**Project Interview:** 3 quick-pick questions plus 1 optional open-ended question. Keep it fast — the user should be done in under 30 seconds.\n1. **Type?** — Feature Build / Testing / Research / Refactor / Other\n2. **Size?** — Quick (1 session) / Medium (2-3 sessions) / Large (4+ sessions)\n3. **Track in ::ss and ::se?** — Yes / No *(controls whether session start/end briefings include this project's status)*\n4. **Anything else to add?** *(optional, free-text — agent infers where to apply: success criteria, constraints, context, scope notes, etc.)*\n\nAfter the interview, create the project file:\n1. Generate a slug from the description (e.g., \"notification-system\")\n2. Create `projects/[slug].md` with header, executive summary, tasks, and session log\n3. Break the description into concrete tasks — investigate what's needed. If the project involves processing multiple items, list each as a separate task.\n4. Write the executive summary by synthesizing the description + interview answers.\n5. If the user provided additional detail in Q4, apply it to the appropriate section.\n6. Respond: \"Project created: [name] ([type], [size]) — [N] tasks.\"\n\n**Quick-create shortcut:** If the description is clearly a small, straightforward task, the agent may skip the interview and create a lightweight project using \"Other\" type with \"Quick\" size and session tracking on. If in doubt, ask.\n\n**Shepherd behavior:** At `::ss`, the agent scans `projects/` for active projects and nudges the user about unfinished work. Projects with `Track in sessions: yes` get a full status briefing. Projects with `Track in sessions: no` get a quiet one-liner. All active projects are always scanned.\n\n**Task updates during work:** When working on project tasks during a session, update the project file in real time — check off completed tasks and add session log entries. Don't wait for `::se`.\n\n#### ::verbatim [N]\n**Purpose:** Raw output — copy the most recent exchange(s) exactly as they happened. No synthesis, no summary, no cleanup.\n**Payload:** Optional — number of exchanges to copy (default: 1).\n**Prompt to self:** Copy the most recent user message and agent response EXACTLY as written. If a number N is provided (e.g., `::verbatim 3`), copy the last N exchanges. Default is 1.\n\nFormat — use this exactly:\n```\n[User]: (exact user message, copied character for character)\n\n[Agent]: (exact agent response, copied character for character)\n```\n\nWhat \"verbatim\" means — follow these rules without exception:\n- Copy the text exactly. Do not paraphrase. Do not rephrase. Do not \"clean up.\"\n- Preserve typos, incomplete sentences, informal language, and grammatical errors.\n- Preserve line breaks, formatting, and structure as they appeared.\n- Do not add introductions, commentary, or transitions between exchanges.\n- Do not summarize multiple messages into one. Each message is its own block.\n- If in doubt, copy more, not less.\n\nWhat a BAD response looks like (do NOT do this):\n```\n[User]: The user asked about how transcript features could work in Cortex.\n[Agent]: I explained several approaches including bracket triggers and topic-bounded selection.\n```\n\nWhat a GOOD response looks like (do this):\n```\n[User]: could it be something like a default behavior of just literally transcribing the most recent question/answer exchange? sometimes i just need the ability to copy/paste if I want to\n\n[Agent]: Oh — that's much simpler and more practical than what I was overcomplicating. You just want the last exchange, raw, so you can grab it...\n```\n\n#### ::wtf payload\n**Purpose:** Diagnostic — something went wrong.\n**Payload:** Yes — description of the issue.\n**Prompt to self:** Parse the payload as a complaint or question about system behavior. Diagnose the issue: did the trigger run? Is the file present? Is the data stale? If fixable, fix it and explain what happened. If not fixable, explain why and suggest a workaround. Keep response under 5 lines.\n\n#### ::uninstall\n**Purpose:** Remove Cortex from this workspace (preserves data).\n**Payload:** No\n**Prompt to self:** Delete this cortex.md file from the workspace root. Remove the Cortex bootstrap block from the platform context file if one exists (replit.md, CLAUDE.md, .cursorrules, .windsurfrules). Leave `cortex/data/` intact — never delete the data directory. Respond: \"Cortex uninstalled. Your data directory is preserved at cortex/data/.\"\n\n#### ::nt code description\n**Purpose:** Create a new custom trigger.\n**Payload:** Yes — trigger code + purpose description.\n**Prompt to self:** Parse: first word = trigger code, remainder = purpose/description. Validate the code doesn't conflict with a standard trigger code. Create a new entry or append to `triggers/custom.md` with the trigger definition in this same format (`#### ::code`, Purpose, Prompt to self). Write a concise prompt-to-self based on the description. The trigger is immediately available — no restart needed. Respond: \"Trigger ::[code] created (custom).\"\n\n#### ::nt?\n**Purpose:** Show how to create a trigger.\n**Payload:** No\n**Prompt to self:** Respond with exactly:\n```\n::nt code description\nExample: ::nt standup Report what I did, blockers, and next steps\nCustom triggers are saved to cortex/data/triggers/custom.md.\n```\n\n#### ::update\n**Purpose:** Check for and apply the next Cortex version update.\n**Payload:** No\n**Prompt to self:** This trigger checks for a newer version of Cortex on GitHub and applies the next incremental update via a manifest. Follow these steps:\n\n1. **Read local version.** Get the version from line 1 of the slim file (`cortex/cortex.md`). Format: `# Cortex vX.Y.Z`. Extract X.Y.Z.\n\n2. **Fetch remote version.** Fetch `https://raw.githubusercontent.com/dvn66/cortex/main/cortex.md`. Read line 1 to extract the remote version number. If the fetch fails, respond: \"Couldn't reach GitHub — check your connection and try again.\"\n\n3. **Compare versions.** Parse both as semver.\n   - If local >= remote: Respond: \"You're on Cortex vX.Y.Z (latest).\" Stop.\n   - If local < remote: Continue to step 4.\n\n4. **Determine next version.** The next version is one minor bump from the local version (e.g., local v2.2 → next v2.3). Even if the remote is v2.5, this update only goes to v2.3. One hop at a time.\n\n5. **Fetch update manifest.** Fetch `https://raw.githubusercontent.com/dvn66/cortex/main/updates/v{next}.json` where `{next}` is the next version string (e.g., `v2.3`). If the fetch fails, respond: \"Update manifest for v{next} not found. Check github.com/dvn66/cortex/releases for manual update instructions.\"\n\n6. **Validate manifest.** Verify that the manifest's `from` field matches the local version. If it doesn't match, respond: \"This update is for v{from} but you're on v{local}. Run ::update to get the correct update.\" Stop.\n\n7. **Fetch release notes.** Fetch the GitHub Release for the next version from `https://api.github.com/repos/dvn66/cortex/releases/tags/v{next}`. Extract the release body. If the fetch fails, note \"Release notes unavailable\" but continue with the update.\n\n8. **Show update summary.** Present to user:\n   ```\n   Update available\n   Current: vX.Y.Z\n   Next:    vA.B.C\n   [If remote is further ahead: \"(latest is vD.E.F — run ::update again after this)\"]\n\n   Files to update:\n   - [list each file path from the manifest]\n\n   What's new:\n   [Release notes from GitHub Release, or \"Release notes unavailable\"]\n\n   This will update system files only. Your data (memory, diary, projects,\n   principles, vocabulary, custom triggers) will not be touched.\n   ```\n\n9. **Ask for confirmation.** \"Apply update? (yes/no)\"\n\n10. **On confirmation:** For each file in the manifest's `files` array:\n    a. Validate the path is system-owned. System-owned files: `cortex.md`, `data/system/rules.md`, `data/system/architecture.md`, `data/system/genesis.md`, `data/triggers/standard.md`. If a path targets user data (`data/principles/*`, `data/memory/*`, `data/diary/*`, `data/projects/*`, `data/vocabulary.md`, `data/triggers/custom.md`, `data/templates/*`, `data/archive/*`), skip it and warn: \"Skipped [path] — user data files cannot be updated automatically.\"\n    b. Create a `.bak` backup of the existing local file.\n    c. Write the `content` from the manifest to the `path` location, replacing the file entirely.\n    After all files are written, re-run the core boot steps directly: read updated system files (rules.md, architecture.md), read updated triggers (standard.md), read principles, activate monitoring. Do NOT call `::ss` recursively.\n    Respond:\n    ```\n    Updated Cortex vX.Y.Z → vA.B.C\n    [N] files updated: [list of filenames]\n    Cortex rebooted.\n    [If remote is further ahead: \"Another update is available — run ::update again.\"]\n    ```\n\n11. **On decline:** Respond: \"Update skipped. Run ::update anytime.\"\n\n**Safety rules:**\n- NEVER modify user data files during an update.\n- Always create `.bak` backups before overwriting any file.\n- Always show the user what will change before applying.\n- Always get explicit confirmation before writing files.\n- One version hop per invocation. Never skip versions.\n\n---\n\n## Internal Triggers (automatic, silent)\n\nThese fire automatically as part of the agent's workflow. The user doesn't see them unless they ask.\n\n#### after-task-complete\n**When:** After completing any task.\n**Action:** Scan the work just done for candidate principles — patterns, conventions, decisions, constraints. If found, append to the appropriate principles file and briefly note: \"Captured: [summary].\"\n\n#### after-bug-fix\n**When:** After fixing a bug or resolving an error.\n**Action:** Capture the failure pattern in `memory/lessons.md`. Format: date, what broke, why, prevention.\n\n#### pre-work\n**When:** Before starting implementation of a new feature or major refactor.\n**Action:** Read all files in `principles/`. Check `memory/active.md` for related open issues. Internalize. Proceed with work.\n\n#### vocabulary-capture\n**When:** During conversation, when the user uses shorthand, defines a term, or coins project-specific vocabulary.\n**Action:** Append the term and its meaning to `vocabulary.md`. Briefly note: \"Added to vocabulary: [term].\"\n"
    },
    {
      "path": "cortex/data/principles/goals.md",
      "content": "# Goals\n"
    },
    {
      "path": "cortex/data/principles/rules.md",
      "content": "# Rules\n\n- **Communicate outcomes, not implementation:** Report what was done and what it means — never file paths, line numbers, trigger counts, or internal structure. If something fails, say what went wrong and what to do next.\n"
    },
    {
      "path": "cortex/data/memory/active.md",
      "content": "# Active Memory\n"
    },
    {
      "path": "cortex/data/memory/lessons.md",
      "content": "# Lessons\n"
    },
    {
      "path": "cortex/data/vocabulary.md",
      "content": "# Vocabulary\n\n## Knowledge Tiers\n\n- **Principles** — How we should act.\n- **Lessons** — Things we learned.\n- **Vocabulary** — Our shared dictionary.\n- **Active memory** — What's relevant right now.\n- **Projects** — Collections of knowledge centered around a mission.\n- **Diary** — A narrative of what happened.\n- **Considerations** — Things connected to our work that might matter later.\n- **Profile** — Who we're working with.\n\n## Project Terms\n\n## Shorthand\n\n- **::ss** — Session start\n- **::se** — Session end\n- **::lt** — Live test / health check\n- **::n** — Quick note to diary\n- **::d** — Write diary narrative\n- **::r** — Review all principles\n- **::ingest** — Capture knowledge\n- **::p** — Alias for ::ingest\n- **::proj** — Project management\n- **::verbatim** — Raw copy of exchanges\n- **::wtf** — Diagnostic\n- **::nt** — Create new trigger\n- **::?** — List all triggers\n"
    },
    {
      "path": "cortex/data/triggers/custom.md",
      "content": "# Custom Triggers\n"
    },
    {
      "path": "cortex/data/memory/profile.md",
      "content": "# Profile\n"
    },
    {
      "path": "cortex/data/memory/considerations.md",
      "content": "# Considerations\n"
    }
  ]
}
